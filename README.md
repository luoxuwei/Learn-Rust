# 内存管理

1.没有垃圾回收机制的语言都要处理内存分配和回收，c、c++ 需要手动管理，rust是通过所有权机制管理内存。

2.内存方面会产生的主要问题是  1）指向的内存没有释放，泄漏了（野指针），2） 指向的内存被释放了，这个指针还在被使用（悬空指针），3）指针被多次释放。

3.可能发生这些问题典型的场景是，类或结构体里保存了指针，就会面对浅拷贝和深拷贝的问题。一般带有指针的结构体或类的对象在出作用域的时候会释放指针指向的内存，如果在作用域里发生了赋值传递的行为， 创建了a对象，a=b， 将a对象赋值给b对象，默认是浅拷贝，a和b内的指针指向同一块内存，当a和b出作用域的时候都会释放一次内存，就会发生同一块内存被释放多次的问题。

4.在rust里，是通过move机制处理这个问题的。发生赋值操作后，所有权转移，之前的对象就失效无法访问。这样就不会产多次释放的问题。move语义还有在不同作用域之间传递的作用。在c、c++中出作用域后就会回收类对象中指针指向的内存，rust中，如果将对象赋值给作用域之前的对象，将所有权传递给作用域外面，在作用域中的对象出作用域时不会发生drop。

5.Copy特征，实现copy特征的结构体，在赋值操作后不会发生所有权转移。

6.& 引用，不能修改，&mut  借用，可以修改。

7.let ms  = &mut s 一个对象被借用后，println!("",s) 报错，不能被使用，let s1=& s, println("",s1) 报错，这个对象的引用也一样不能被使用，除非这个借用ms 出作用域。



